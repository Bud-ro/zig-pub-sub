- [ ] Implement a few more data components
  - [x] Implement and design a virtual data component
    - [x] ~~Think of a way to programmatically extend an existing virtual data component or its configuration so that just one can be used. Appliance API is essentially just a special virtual data component.~~ Not going to do this.
    - [x] Implement as function calls, while still retaining type safety.
  - [x] System Data bump allocator ~~data component~~ top level variable. 
    - Designed to last for a single run-to-completion (RTC). 
    - Can be used instead of stack allocator, which is only capable of a fixed number of allocation sizes
    - Improves memory report since it removes implicit assumption that we have enough stack space to support them
      - It does assume that we don't exceed 2 kiB (or however much configured) of scratch space used per RTC
  - [ ] Converted data component once subscriptions are in implemented
    - [ ] Subscribe to ERDs in it
    - [ ] Denote *multiple* ERDs as a dependency
- [x] Implement System Data
  - [ ] Define ERDs top down (pass down from system data into other components)
    - Can probably do this by calling `SystemData(ErdDefinitions)`, that's just a ton of work
    - This buys:
      - Fully committing to storing subscriptions in data components
      - Differing `.subscribe`, `.unsubscribe`, etc. functions for instance, which more flexibly allow for certain data components to not be subscribable
      - Allows for init of data components with different ERD tables
  - [x] Allow for definition of public ERD handles
  - [ ] Explore usage of monotone minimal perfect hashing functions. 
    - [ ] Public handle -> internal index. Need to ensure values outside the set can be detected. 
    - [x] Internal idx -> Public handle: This one is better done via direct-indexed lookup table. Duh.
    - [ ] Ensure that speedup is worth vs just using binary search
- [x] Pub sub
  - [x] ~~Subscription lists are stored local to data components~~, ~~Subscription Linked List Stored in System Data~~, Subscription lists stored in system data
    - [x] ERDs that don't make sense to subscribe to can cause a compile error
    - [x] ~~Entire data components can have their subscribe function be a `@compileError`~~ N/A since sub is done at the system data level
  - [x] ~~Linked List unsubscribe~~
  - [ ] `.subscribe_all` and `.unsubscribe_all`
  - [x] `comptime` known upper bound of subscriptions which can be used to hold callbacks in an array instead of wasting a shit ton of memory (and time) on linked list pointers.
    - Benefit of this is that you don't need to explicitly mark ERDs as Sub_Y, it will just be inferred from whether it's ever subbed to
    - Unsubscribe removes the corresponding function pointer and moves the last function pointer in the array to the empty position to maintain memory continuity
      - This is only possible if order of the callbacks doesn't matter. FYI it SHOULDN'T matter.
    - Could be done by storing a comptime counter in the ERD table.
  - [ ] External data capabilities in `SystemData`
    - [ ] Swapping done automatically using `@typeInfo`
    - [ ] Reads/writes are done using public ERD handles, so you don't really get any type safety (TODO: is this true?)
    - [ ] Pub sub at this layer as well, only for ERDs that have `ErdHandle`s
- [ ] JSON Serializer for SystemErds
- [ ] Zig alternative to Lua for generating parametric data
- [ ] Rename this project to embedded starter kit
- [x] Timer Module with linked lists
  - [x] Timer Module memory/speed optimization using pointer alignment abuse
  - [x] Add support for paused timers
- [x] ~~Timer Module using struct of arrays, and pseudo-linked list~~
- [ ] Build ELF for Cortex-M
  - [ ] Linker script
  - [ ] Flash just the application
  - [ ] Flash the application + ethically sourced bootloader