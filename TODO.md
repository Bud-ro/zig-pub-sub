- [ ] Implement a few more data components
  - [x] Implement and design a virtual data component
    - [x] ~~Think of a way to programmatically extend an existing virtual data component or its configuration so that just one can be used. Appliance API is essentially just a special virtual data component.~~ Not going to do this.
    - [x] Implement as function calls, while still retaining type safety.
  - [x] System Data bump allocator ~~data component~~ top level variable. 
    - Designed to last for a single run-to-completion (RTC). 
    - Can be used instead of stack allocator, which is only capable of a fixed number of allocation sizes
    - Improves memory report since it removes implicit assumption that we have enough stack space to support them
      - It does assume that we don't exceed 2 kiB (or however much configured) of scratch space used per RTC
  - [ ] External data component
    - [ ] Swapping
    - [ ] Reads/writes are done using public ERD handles, so you don't really get any type safety (TODO: is this true?)
  - [ ] Converted data component once subscriptions are in implemented
    - [ ] Subscribe to ERDs in it
    - [ ] Denote *multiple* ERDs as a dependency
- [x] Implement System Data
  - [ ] Define ERDs top down (pass down from system data into other components)
    - This buys:
      - Fully committing to storing subscriptions in data components
      - Differing `.subscribe`, `.unsubscribe`, etc. functions for instance, which more flexibily allow for certain data components to not be subscribable
      - Allows for init of data components with different ERD tables
  - [x] Allow for definition of public ERD handles
- [x] Pub sub
  - [x] ~~Subscription lists are stored local to data components~~, ~~Subscription Linked List Stored in System Data~~, Subscription lists stored in system data
    - [x] ERDs that don't make sense to subscribe to can cause a compile error
    - [x] ~~Entire data components can have their subscribe function be a `@compileError`~~ N/A since sub is done at the system data level
  - [x] ~~Linked List unsubscribe~~
  - [ ] `.subscribe_all` and `.unsubscribe_all`
  - [x] `comptime` known upperbound of subscriptions which can be used to hold callbacks in an array instead of wasting a shit ton of memory (and time) on linked list pointers.
    - Benefit of this is that you don't need to explicitly mark ERDs as Sub_Y, it will just be inferred from whether it's ever subbed to
    - Unsubscribe removes the corresponding function pointer and moves the last function pointer in the array to the empty position to maintain memory continuity
      - This is only possible if order of the callbacks doesn't matter. FYI it SHOULDN'T matter.
    - Could be done by storing a comptime counter in the ERD table.
- [ ] JSON Serializer for SystemErds
- [ ] Zig alternative to Lua for generating parametric data
- [ ] Rename this project to embedded starter kit
- [x] Timer Module with linked lists
- [ ] Timer Module using struct of arrays, and psuedo-linked list
  - [ ] `comptime` configured upper bound of timers 
    - [ ] Application test will tell you when to increase this number (`application.init(); assert(timer_module.active_timers >= 0.90*max_timers)`)
  - [ ] Use handles with generation for modifications to a timer
    - [ ] Callbacks will return the timer handle
- [ ] Hardware Interfaces
- [ ] Build ELF for Cortex-M
  - [ ] Linker script
  - [ ] Flash just the application
  - [ ] Flash the application + ethically sourced bootloader